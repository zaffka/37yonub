---
layout: post
title:  "Про "загоны" профи-разработчиков на Go"
date:   2020-04-11
categories: golang
comments: true
---
Когда-то, будучи PM-ом, на разработку софта я смотрел с одного ракурса. Работа над кодом не начиналась, пока проектным отделом не была детально прописана и согласована постановка, отрисованы макеты интерфейсов, нарисованы "кубики" модулей системы, обозначены роли и зоны ответственности участников и компонентов. И когда состоялось знакомство с Go, проектная база идеально легла на концепции языка.

Теперь я пишу код сам, но, следуя старым привычкам, стараюсь чётко формализовывать требования к  "кирпичикам", из которых складываю приложения и использовать все возможности языка. Однако так делают оооочень далеко не все коллеги, с которыми довелось трудиться в команде. О нескольких стрёмных "загонах" профессиональных разработчиков хочется рассказать. Спойлер - не делайте так! ;)  

## Стрёмный загон 1: Использование контекста
Интригует заголовок? ;) Ведь, казалось бы, контекст - одна из ключевых концепций golang, да?  
Кажется на Хабре даже кто-то писал, что разработчик, пробующийся на должность гофера в Google и пропустивший контекст в сигнатуре любой функции, собеседование гарантированно не пройдёт.  

Но посмотрите на скриншот ниже.  
![ golang context hell](/assets/img/ctxhell.jpg){:class="img-responsive"}  
 
Да, вам не показалось, тут каждый сабпакет монолита начинается с объявления корневого контекста!

На мой вопрос - зачем так сделано, был дан ответ, что приложение не должно завершать работу, если что-то из сабкомпонентов находится в процессе общения с удалёнными системами. На вопрос, почему не прервать эту long polling деятельность, протянув единый контекст, завершиться с ошибкой и заново поставить задачу в очередь на выполнение после рестарта - последовал ответ, что это нештатное завершение приложения и так делать нельзя, т.к. можно потерять данные. Тут у всех PM-ов должен задёргаться глаз, ибо завершение с ошибкой - это всего-лишь одна из веток сценария, штатное завершение работы. И в наших силах организовать безопасную обработку без потерь.  

Но победить этот странный загон я не смог, причём данные всё равно терялись, т.к. время ожидания ответа удалённых систем было почти всегда меньше, чем серверный таймаут, после которого приложение убивалось системой.

# Стрёмный загон 2: Повсеместное использование state management
Тот же проект. Каждый сабпакет снабжён функциями Start-Stop. Которые завёрнуты в вэйтгруппы. Подход официально прописан в регламентах компании, как обязательный при проектировании пакетов. OMFG.  

Т.е. вы отрезаете контекст, но вкорячиваете стейт менеджмент взамен. Ваш проект **никогда** не завершается деликатно, но вы не видите в этом противоречий с декларацией "мы не должны терять данные".  

И да, я вовсе не хочу сказать, что sm не нужен никогда.   
Но например, если вы приличный PM, при написании use case (дай бог здоровья [Alistair Cockburn](https://en.wikipedia.org/wiki/Alistair_Cockburn){:target="_blank"}) вы должны пытаться смоделировать, кто именно будет пользоваться вашим сервисом - домохозяйка, школьник, строитель и т.п. Также и с дизайном кода - вы должны держать в голове, кто им будет пользоваться. Тогда решение добавлять или не добавлять sm - станет очевидным. В большинстве случаев, для среднего разработчика-пользователя, можно спроектировать sm-free пакет.  

По этому вопросу очень рекомендую посмотреть видео Богдана Сторожука [How to design a Go library](https://youtu.be/PgWrgPYpmE8){:target="_blank"}

Я, опять же, потерпел фиаско, пытаясь объяснить очевиднейшие нестыковки в подходе sm vs context. Причём дошло до смешного, разработчики с 20-ти летним стажем стали смеяться надо мной, мол ты-то нас сейчас научишь (facepalm).

# Стрёмный загон 3: Отказ от бродкаста закрытием канала
```go
ch := make(chan struct{})
close(ch)
<-ch
```
Гоферы поймут, что тут происходит. Чтение из закрытого канала в Go не запрещено. Причём, после закрытия канала, все ридеры будут бесконечно получать пустую структуру. С помощью такого подхода можно очень просто сделать бродкаст сигнала по всему дереву горутин.  
Дёшево и сердито.

Но, опять же, от парочки разработчиков уровня senior я однажды получил запрет на подобный подход.   
Это "хак" - и всё тут %))
Предложение заглянуть под капот [Shutdown-метода из гошного http-пакета](https://golang.org/pkg/net/http/#Server.Shutdown){:target="_blank"} ни разу не помогло. Зато, в дополнение, прозвучал the-best-спич, что гугловые разработчики просто не шарят и скорее всего этот код просто писан в доконтекстовые времена (facepalm).