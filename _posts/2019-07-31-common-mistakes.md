---
layout: post
title:  "10 наиболее распространённых ошибок в проектах на Go"
date:   2019-07-31
categories: golang
comments: true
---
Перевод статьи [The Top 10 Most Common Mistakes I’ve Seen in Go Projects](https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65){:target="_blank"} от [Teiva Harsanyi](https://twitter.com/teivah){:target="_blank"} о наиболее часто встречающихся ошибках в проектах на Golang.

## 1. Значение по-умолчанию для перечисляемых(enum) типов
Взглянем на простой кусочек кода
```go
type Status uint32

const (
	StatusOpen Status = iota
	StatusClosed
	StatusUnknown
)
```
В нём мы создаём последовательность enum-переменных, содержащих следующие значения:
```
StatusOpen = 0
StatusClosed = 1
StatusUnknown = 2
```
Представим, что наш тип `Status` является частью запроса и будет кодироваться или декодироваться, например, в JSON. Для этого будет использована такая структура:
```go
type Request struct {
	ID        int    `json:"Id"`
	Timestamp int    `json:"Timestamp"`
	Status    Status `json:"Status"`
}
```
Представим, что обрабатываем вот такой JSON-запрос:
```json
{
  "Id": 1234,
  "Timestamp": 1563362390,
  "Status": 0
}
```
Казалось бы, ничего особенного? Статус, который мы получим, соответствует `StatusOpen`, так?

Но взглянем на другой запрос, в котором значение статуса не определено (неважно по какой причине):
```json
{
  "Id": 1234,
  "Timestamp": 1563362390
}
```
В этом случае поле `Status` нашей структуры типа `Request` будет проинициализировано **нулевым значением** (для `uint32` типа это 0). Таким образом, вместо `StatusUnknown` в структуре, мы получим `StatusOpen`.

Правильным решением будет начать нашу enum-последовательность как раз со `StatusUnknown`:
```go
type Status uint32

const (
	StatusUnknown Status = iota
	StatusOpen
	StatusClosed
)
```
Тогда, даже если поле `Status` будет отсутствовать в JSON-запросе, то поле `Status` в структуре будет иметь ожидаемое значение -- 0, соответствующее `StatusUnknown`.

## 2. Тестирование производительности (benchmarking)
Тестировать производительность кода тяжело из-за огромного количества факторов, влияющих на итоговый результат.

Одна из часто встречающихся ошибок связана с особенностями работы компилятора. Возьмём конкретный пример из [teivah/bitvector](https://github.com/teivah/bitvector/){:target="_blank"}:
```go
func clear(n uint64, i, j uint8) uint64 {
	return (math.MaxUint64<<j | ((1 << i) - 1)) & n
}
```
Данная функция чистит биты в заданном диапазоне. Протестировать её производительность мы можем примерно так:
```go
func BenchmarkWrong(b *testing.B) {
	for i := 0; i < b.N; i++ {
		clear(1221892080809121, 10, 63)
	}
}
```
Однако, в данном бенчмарке компилятор примет во внимание, что `clear` -- это функция-лист (не вызывает никаких других функций) и будет выполнять её содержимое как inline-последовательность инструкций. После чего, компилятор определит, что `clear` не имеет никаких побочных эффектов(side-effects), т.е. никак не влияет на среду исполнения. После чего вызов `clear` будет просто удалён.

Один из вариантов избежать сценария выше -- присваивать результат выполнения функции переменной уровня пакета. Примерно так:
```go
var result uint64

func BenchmarkCorrect(b *testing.B) {
	var r uint64
	for i := 0; i < b.N; i++ {
		r = clear(1221892080809121, 10, 63)
	}
	result = r
}
```
Здесь компилятор не будет знать, есть ли у функции side-effect и бенчмарк будет точен.

## 3. Указатели! Указатели везде!
В Go, в большинстве случаев, передача переменной по значению создаст копию этой переменной. В то время как передача посредством указателя просто скопирует адрес переменной в памяти.

Кажется, что передача указателя всегда будет работать быстрее, не так ли?

Если вы с этим согласны, взгляните на [этот пример](https://gist.github.com/teivah/a32a8e9039314a48f03538f3f9535537){:target="_blank"}.
Это бенчмарк для структуры данных размером 0.3Кб, которую мы сначала передаём посредством передачи указателя, а затем по значению. 0.3Кб -- не очень большой размер данных, но это должно быть примерно похоже на те данные, которыми мы оперируем каждый день.

Когда я запускаю этот бенчмарк, на моей системе передача по значению отрабатывает более чем **в четыре раза** быстрее, чем передача по указателю. Результат несколько неочевиден, не так ли?

Объяснение этому феномену -- в способе управления памятью Go. Я не смогу объяснить это лучше, чем [Билл Кеннеди](https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html){:target="_blank"}, но позвольте мне сделать выжимку из его статьи.

Память под переменную может быть выделена в куче(heap) или стеке(stack).

Очень приблизительно:
* Стек содержит последовательность переменных для заданной горутины. Как только функция завершила работу, переменные вытесняются из стека.
* Куча содержит общие(shared) переменные (глобальные и т.п.)

Давайте рассмотрим простой пример, в котором вы возвращаем значение:
```go
func getFooValue() foo {
	var result foo
	// Do something
	return result
}
```

Здесь переменная `result` создаётся в текущей горутине. И эта переменная помещается в стек. Как только функция завершает работу, клиент получает копию этой переменной. Исходная переменная вытесняется из стека. Эта переменная всё ещё существует в памяти, до тех пор, пока не будет затёрта другой переменной, но к этой переменной **уже нельзя получить доступ**.

Теперь тот же пример, но с указателем:
```go
func getFooPointer() *foo {
	var result foo
	// Do something
	return &result
}
```

Переменная `result` также создаётся текущей горутиной, но клиент получает указатель (копию адреса переменной). Если `result` вытеснена из стека, клиент функции **не сможет получить доступ к переменной**.

В подобном сценарии компилятор Go вынужден переместить переменную `result` туда, где она может быть доступна(shared) -- в кучу(heap).

Хотя есть и исключение. Для примера:
```go
func main()  {
	p := &foo{}
	f(p)
}
```

Поскольку мы вызываем функцию `f()` в той же горутине, что и функцию `main()`, переменную `p` не нужно перемещать. Она просто находится в стеке и вложенная функция `f()` будет иметь к ней доступ.

По этим причинам метод `Read` интерфейса `io.Reader` принимает слайс в качестве параметра, а не возвращает его. Возврат слайса (а слайс всегда -- указатель) приведёт к необходимости перемещать данные в кучу(heap).

Но почему стек так быстр? Основных причин две:
* Стеку не нужно иметь сборщик мусора(garbage collector). Как мы уже упоминали, переменные просто создаются и затем вытесняются, когда функция завершается. Не нужно запускать сложный процесс освобождения памяти от неиспользуемых переменных и т.п.
* Стек принадлежит одной горутине, переменные не нужно синхронизировать в сравнении с теми, что находятся в куче. Что также повышает производительность.

В качестве заключения, когда мы создаём функцию - поведением по-умолчанию должно быть **использование передачи по значению, а не по указателю**. Указатель должен быть использован только когда мы действительно хотим переиспользовать данные.

Таким образом, если мы страдаем от проблем с производительностью, один из возможных способов оптимизации -- убедиться, что, в каждом конкретном случае, использование указателей обосновано.
Узнать, в каких случаях компилятор вынужден перемещать данные в кучу, можно командой `go build -gcflags "-m -m"`.

Но, ещё раз, для большинства повседневных случаев, передача по значению -- лучший выбор.

...статья в процессе перевода...