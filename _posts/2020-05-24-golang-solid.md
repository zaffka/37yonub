---
layout: post
title:  "SOLID-принципы в Go"
date:   2020-05-24
categories: golang
comments: true
---
Влившись в коммерческую разработку на Golang, с удивлением обнаружил, что многие маститые разработчики или не умеют или сознательно не используют SOLID-принципы при написании кода на Go. Вероятно, это связано с тем, что Go - не объектно-ориентированный ЯП, а SOLID обычно упоминают как раз в контексте ООП. Опытный разработчик, КМК, склонен воспринимать "нет ООП", как некое упрощение или недостаток. Но это не так. Go - полноценный язык, безо всяких скидок. Поэтому solid-принципы можно и нужно в нём применять. Предлагаю рассмотреть каждый из принципов на примерах. Поехали.

# Single Responsibility principle, принцип единственной ответственности
Принцип декларирует, что каждый тип должен иметь одну зону ответственности и, как следствие, единственную причину к изменениям.

**Так не делай** &#8628;
{% gist a5c6ec935226fd7441bb2fc4e6c9f0ff single_responsibility_bad.go %}
Смешивать методы манипулирования данными конверта `Envelope` и механизмы сохранения\извлечением этих данных из БД - не стоит.

**Делай так** &#8628;
{% gist 0171cc56d66dc491a136fd9afc254c5b single_responsibility_good.go %}
&#10003; Манипуляции над данными `Envelope` - отдельно, работа с БД - отдельно.

# Open Closed principle, принцип открытости-закрытости
Принцип открытости-закрытости звучит как "класс должен быть открыт для расширения, но закрыт от модификации". Смысл в том, чтобы иметь возможность делать поведение сущности более разнообразным, не вмешиваясь в готовую реализацию.

**Так не делай** &#8628;
{% gist bd45395a06a4bc1db3b11bfae6506e3d open_closed_bad.go %}
В данном примере, для фильтрации списка президентов, создаются новые методы существующей структуры `BadFiltering`, что будет иметь влияние на все пакеты, где фильтрация используется.

**Делай так** &#8628;
{% gist e5f41449f217660ceb5c46d5690df045 open_closed_good1.go %}

**Или так** &#8628;
{% gist a1578049896ec04e809c4e9fafea4943 open_closed_good2.go %}

&#10003; Фильтрация производится в соответствии со спецификацией, соответствующей Parametr-интерфейсу или просто задаётся любой функцией-параметром. В том числе, при необходимости, можно сделать variadic-набор фильтров. Поведение `GoodFiltering` не меняется, а разработчик в любом месте кода может расширить функционал.

# Liskov Substitution principle, принцип подстановки Барбары Лисков
Класс-потомок не должен сильно отличаться от родителя.  
Широко известный в Go-комьюнити [Dave Cheney](https://dave.cheney.net/2016/08/20/solid-go-design){:target="_blank"} по этому поводу пишет:  
>The Liskov Substitution Principle encourages you to express the dependencies between your packages in terms of interfaces, not concrete types. By defining small interfaces, we can be more confident that implementations will faithfully satisfy their contract.

*Принцип подстановки Барбары Лисков [в Go] побуждает тебя выражать зависимости между пакетами в терминах интерфейсов, а не конкретных типов. Объявляя небольшие интерфейсы, мы можем быть уверены, что реализации будут добросовестно удовлетворять их контракту.*

**Так не делай** &#8628;
{% gist bd45395a06a4bc1db3b11bfae6506e3d liskov_bad.go %}
В данном примере, для фильтрации списка президентов, создаются новые методы существующей структуры `BadFiltering`, что будет иметь влияние на все пакеты, где фильтрация используется.

**Делай так** &#8628;
{% gist e5f41449f217660ceb5c46d5690df045 liskov_good.go %}

# Interface Segregation Principle, принцип разделения интерфейса
# Dependency Inversion Principle, принцип инверсии зависимостей