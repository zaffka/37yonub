---
layout: post
title:  "SOLID-принципы, как это выглядит в Go"
date:   2020-05-24
categories: golang
comments: true
---
Влившись в коммерческую разработку на Golang, с удивлением обнаружил, что многие маститые разработчики или не умеют или сознательно не используют SOLID-принципы при написании кода на Go. Вероятно, это связано с тем, что Go - не объектно-ориентированный ЯП, а SOLID обычно упоминают как раз в контексте ООП. Опытный разработчик, КМК, склонен воспринимать "нет ООП", как некое упрощение или недостаток. Но это не так. Go - полноценный язык, безо всяких скидок. Поэтому solid-принципы можно и нужно в нём применять. Предлагаю рассмотреть каждый из принципов на примерах. Поехали.

# S - Single Responsibility principle, принцип единственной ответственности
Принцип декларирует, что каждый тип должен иметь одну зону ответственности и, как следствие, единственную причину к изменениям.

{% gist c08ee0f2726fd0e3909d test.md %}

# O - Open Closed principle, принцип открытости-закрытости
# L - Liskov Substitution principle, принцип подстановки Барбары Лисков
# I - Interface Segregation Principle, принцип разделения интерфейса
# D - Dependency Inversion Principle, принцип инверсии зависимостей