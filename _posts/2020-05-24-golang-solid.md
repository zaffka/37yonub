---
layout: post
title:  "SOLID-принципы в Go"
date:   2020-05-24
categories: golang
comments: true
---
Влившись в коммерческую разработку на Golang, с удивлением обнаружил, что многие маститые разработчики или не умеют или сознательно не используют SOLID-принципы при написании кода на Go. Вероятно, это связано с тем, что Go - не объектно-ориентированный ЯП, а SOLID обычно упоминают как раз в контексте ООП. Опытный разработчик, КМК, склонен воспринимать "нет ООП", как некое упрощение или недостаток. Но это не так. Go - полноценный язык, безо всяких скидок. Поэтому solid-принципы можно и нужно в нём применять. Предлагаю рассмотреть каждый из принципов на примерах. Поехали.

**Содержание**
* [Single Responsibility principle](#single-responsibility-principle-принцип-единственной-ответственности)
* [Open Closed principle](#open-closed-principle-принцип-открытости-закрытости)
* [Liskov Substitution principle](#liskov-substitution-principle-принцип-подстановки-барбары-лисков)
* [Interface Segregation Principle](#interface-segregation-principle-принцип-разделения-интерфейсов)
* [Dependency Inversion Principle](#dependency-inversion-principle-принцип-инверсии-зависимостей)

# Single Responsibility principle, принцип единственной ответственности
Принцип декларирует, что каждый тип должен иметь одну зону ответственности и, как следствие, единственную причину к изменениям.

**Так не делай** &#8628;
{% gist a5c6ec935226fd7441bb2fc4e6c9f0ff single_responsibility_bad.go %}
Смешивать методы манипулирования данными конверта `Envelope` и механизмы сохранения\извлечением этих данных из БД - не стоит.

**Делай так** &#8628;
{% gist 0171cc56d66dc491a136fd9afc254c5b single_responsibility_good.go %}
&#10003; Манипуляции над данными `Envelope` - отдельно, работа с БД - отдельно.

# Open Closed principle, принцип открытости-закрытости
Принцип открытости-закрытости звучит как "класс должен быть открыт для расширения, но закрыт от модификации". Смысл в том, чтобы иметь возможность делать поведение сущности более разнообразным, не вмешиваясь в готовую реализацию.

**Так не делай** &#8628;
{% gist bd45395a06a4bc1db3b11bfae6506e3d open_closed_bad.go %}
В данном примере, для фильтрации списка президентов, создаются новые методы существующей структуры `BadFiltering`, что будет иметь влияние на все пакеты, где фильтрация используется.

**Делай так** &#8628;
{% gist e5f41449f217660ceb5c46d5690df045 open_closed_good1.go %}

**Или так** &#8628;
{% gist a1578049896ec04e809c4e9fafea4943 open_closed_good2.go %}

&#10003; Фильтрация производится в соответствии со спецификацией, соответствующей Parametr-интерфейсу или просто задаётся любой функцией-параметром. В том числе, при необходимости, можно сделать variadic-набор фильтров. Поведение `GoodFiltering` не меняется, а разработчик в любом месте кода может расширить функционал.

# Liskov Substitution principle, принцип подстановки Барбары Лисков
>Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы

Или, иначе говоря, класс-потомок не должен сильно отличаться от родителя, т.е. должен быть способен выполнять те же действия и получать тот же результат.  

В терминах Go, реализации должны *добросовестно удовлетворять контракту(интерфейсу)*. А сами интерфейсы желательно делать небольшими. 

В примере ниже реализации интерфейса `FeeHandler` для типов `Currency` и `Stock` отличаются, т.к. в случае со стоками мы заявили равенство наценок на цену Ask и Bid, отразили это в реализации. Что привело к ошибке в расчёте среднего значения стоимости и нарушению принципа LSP.  

{% gist b9106188de6d5c1043e0a0895f5343a2 liskov_substitution.go %}
Правильным вариантом реализации для `Stock` будет отдельное присвоение наценки `AskMarkup` и `BidMarkup`.

# Interface Segregation principle, принцип разделения интерфейсов
Много интерфейсов, специализирующихся на конкретных операциях клиентов, лучше, чем один большой и универсальный. Самый очевидный принцип.

**Так не делай** &#8628;
{% gist 1abc6faebc5ee9bd7c733242c41d3524 interface_segregation_bad.go %}

**Делай так** &#8628;
{% gist 4b96e4ff3f0709b6d8dfd338af8a40e7 interface_segregation_good.go %}

# Dependency Inversion principle, принцип инверсии зависимостей
Классы верхнего уровня не должны зависеть и соединяться с классами нижнего уровня, а должены зависеть от абстракций.

**Так не делай** &#8628;
{% gist 63a12fd53843684f03a2096c6a771313 dependency_inversion_bad.go %}
Высокоуровневый `BadStats` зависит от низкоуровневой `DataBase` со вложенными данными типа `Information`.

**Делай так** &#8628;
{% gist 9c39acc6ff83d8715f79809189debad8 dependency_inversion_good.go %}
Высокоуровневый `GoodStats` отделён от низкоуровневых инструментов интерфейсом `Searcher` в структуре `DataBase`.  

Это позволяет легко заменить хранилище данных, например на `PossibleSQL`, без модификации поискового механизма `CardsInfo`.