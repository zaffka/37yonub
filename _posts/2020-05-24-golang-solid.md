---
layout: post
title:  "SOLID-принципы в Go"
date:   2020-05-24
categories: golang
comments: true
---
Влившись в коммерческую разработку на Golang, с удивлением обнаружил, что многие маститые разработчики или не умеют или сознательно не используют SOLID-принципы при написании кода на Go. Вероятно, это связано с тем, что Go - не объектно-ориентированный ЯП, а SOLID обычно упоминают как раз в контексте ООП. Опытный разработчик, КМК, склонен воспринимать "нет ООП", как некое упрощение или недостаток. Но это не так. Go - полноценный язык, безо всяких скидок. Поэтому solid-принципы можно и нужно в нём применять. Предлагаю рассмотреть каждый из принципов на примерах. Поехали.

# Single Responsibility principle, принцип единственной ответственности
Принцип декларирует, что каждый тип должен иметь одну зону ответственности и, как следствие, единственную причину к изменениям.

Так не делай &#8628;
{% gist a5c6ec935226fd7441bb2fc4e6c9f0ff single_responsibility_bad.go %}
Смешивать методы манипулирования данными конверта и механизмы сохранения\извлечением этих данных из БД - не стоит.

Делай так &#8628;
{% gist 0171cc56d66dc491a136fd9afc254c5b single_responsibility_good.go %}
&#10003; Манипуляции над данными конверта - отдельно, работа с БД - отдельно.

# Open Closed principle, принцип открытости-закрытости
# Liskov Substitution principle, принцип подстановки Барбары Лисков
# Interface Segregation Principle, принцип разделения интерфейса
# Dependency Inversion Principle, принцип инверсии зависимостей